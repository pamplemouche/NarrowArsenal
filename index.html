<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Narrow Arsenal - Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="ui"></div>

    <script>
        // CE CODE REMPLACE THREE.JS ET LE MAIN.JS EN UN SEUL BLOC
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");

        const vs = `attribute vec4 position; attribute vec4 color; uniform mat4 uMat; varying vec4 vCol;
                    void main() { gl_Position = uMat * position; vCol = color; }`;
        const fs = `precision mediump float; varying vec4 vCol; void main() { gl_FragColor = vCol; }`;

        function createShader(gl, type, src) {
            const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(prog); gl.useProgram(prog);

        // Données du monde (Sol + Cube)
        const vertices = new Float32Array([
            -50,-0.1,-50, 50,-0.1,-50, 50,-0.1,50, -50,-0.1,50, // Sol
            -1,0,-1, 1,0,-1, 1,2,-1, -1,2,-1,  -1,0,1, 1,0,1, 1,2,1, -1,2,1 // Cube
        ]);
        const colors = new Float32Array([
            0.2,0.6,0.2, 0.2,0.6,0.2, 0.2,0.6,0.2, 0.2,0.6,0.2, // Vert
            0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1, 0.8,0.1,0.1 // Rouge
        ]);

        const pBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, pBuf); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const cBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cBuf); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        let camY = 0;
        
        function render() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            const aspect = canvas.width / canvas.height;
            const cos = Math.cos(camY), sin = Math.sin(camY);
            
            // Matrice simplifiée (Vue + Projection)
            const mat = [
                cos/aspect, 0, sin, 0,
                0, 1, 0, 0,
                -sin/aspect, 0, cos, 0,
                0, -0.5, -5, 1
            ];

            const uLoc = gl.getUniformLocation(prog, "uMat");
            gl.uniformMatrix4fv(uLoc, false, new Float32Array(mat));

            const pLoc = gl.getAttribLocation(prog, "position");
            gl.bindBuffer(gl.ARRAY_BUFFER, pBuf); gl.enableVertexAttribArray(pLoc); gl.vertexAttribPointer(pLoc, 3, gl.FLOAT, false, 0, 0);

            const cLoc = gl.getAttribLocation(prog, "color");
            gl.bindBuffer(gl.ARRAY_BUFFER, cBuf); gl.enableVertexAttribArray(cLoc); gl.vertexAttribPointer(cLoc, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); // Sol
            gl.drawArrays(gl.TRIANGLE_FAN, 4, 4); // Face cube
            
            camY += 0.01;
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>